<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RCOA Server Cluster Maintenance</title>
<style>
  :root {
    --bg: #0a0e17; --surface: #111827; --surface2: #1a2332;
    --border: #2a3a4e; --text: #e2e8f0; --text-dim: #8899aa;
    --healthy: #4ade80; --warning: #facc15; --critical: #f87171;
    --sre-orange: #fb923c; --sre-blue: #60a5fa;
    --accent: #818cf8; --accent2: #c084fc;
    --traffic: #38bdf8;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:var(--bg); color:var(--text); font-family:'SF Mono','Fira Code','Consolas',monospace; overflow-x:hidden; }

  .app-header {
    background:linear-gradient(135deg,#111827 0%,#1e293b 100%);
    border-bottom:1px solid var(--border); padding:18px 28px;
    display:flex; align-items:center; gap:20px;
  }
  .app-header h1 { font-size:1.25em; font-weight:600; }
  .app-header h1 span { color:var(--healthy); }
  .app-header .subtitle { color:var(--text-dim); font-size:0.78em; }

  .main-layout { display:grid; grid-template-columns:300px 1fr 340px; height:calc(100vh - 72px); }

  .panel { background:var(--surface); overflow-y:auto; padding:14px; }
  .panel-left { border-right:1px solid var(--border); }
  .panel-right { border-left:1px solid var(--border); }
  .panel-section { margin-bottom:16px; }
  .panel-section h3 {
    font-size:0.72em; text-transform:uppercase; letter-spacing:1.4px;
    color:var(--accent); margin-bottom:9px; padding-bottom:5px;
    border-bottom:1px solid var(--border);
  }

  .param-row { display:flex; align-items:center; justify-content:space-between; margin-bottom:7px; }
  .param-row label { font-size:0.73em; color:var(--text-dim); flex:1; }
  .param-row input[type=range] { width:96px; accent-color:var(--accent); }
  .param-row .val { font-size:0.73em; color:var(--healthy); width:38px; text-align:right; }

  .btn {
    padding:7px 14px; border:1px solid var(--border); border-radius:4px;
    background:var(--surface2); color:var(--text); font-family:inherit;
    font-size:0.76em; cursor:pointer; transition:all .2s;
  }
  .btn:hover { border-color:var(--accent); background:#1e293b; }
  .btn.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
  .btn.primary:hover { background:#6366f1; }
  .btn.danger { border-color:var(--critical); color:var(--critical); }
  .btn-row { display:flex; gap:7px; margin-top:9px; flex-wrap:wrap; }

  .center-panel { position:relative; background:#080c14; overflow:hidden; }
  #simCanvas { width:100%; height:100%; display:block; }

  .overlay-stats {
    position:absolute; top:12px; left:12px;
    background:rgba(10,14,23,.9); border:1px solid var(--border);
    border-radius:5px; padding:10px 14px; font-size:0.7em; pointer-events:none;
  }
  .overlay-stats .sl { display:flex; gap:10px; margin-bottom:3px; }
  .overlay-stats .sk { color:var(--text-dim); }
  .overlay-stats .sv { color:var(--healthy); }

  .legend-bar {
    position:absolute; bottom:12px; left:12px;
    background:rgba(10,14,23,.9); border:1px solid var(--border);
    border-radius:5px; padding:8px 14px; font-size:0.65em;
    display:flex; gap:14px; pointer-events:none;
  }
  .legend-item { display:flex; align-items:center; gap:5px; }
  .legend-dot { width:8px; height:8px; border-radius:50%; }

  .metric-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:12px; }
  .metric-card {
    background:var(--surface2); border:1px solid var(--border);
    border-radius:5px; padding:9px; text-align:center;
  }
  .metric-card .mv { font-size:1.3em; font-weight:700; }
  .metric-card .ml { font-size:.65em; color:var(--text-dim); margin-top:2px; }

  .chart-box { height:150px; background:var(--surface2); border:1px solid var(--border); border-radius:5px; margin-bottom:11px; position:relative; }
  .chart-box canvas { width:100%; height:100%; }

  .event-log {
    background:var(--surface2); border:1px solid var(--border);
    border-radius:5px; padding:7px; max-height:170px;
    overflow-y:auto; font-size:.64em; line-height:1.7;
  }
  .ev { border-bottom:1px solid #1a2332; padding:1px 0; }
  .ev-patch { color:var(--healthy); }
  .ev-reboot { color:var(--warning); }
  .ev-alert { color:var(--critical); }
  .ev-traffic { color:var(--traffic); }
  .ev-sys { color:var(--sre-blue); }

  .comparison-table { width:100%; font-size:.69em; border-collapse:collapse; margin-top:7px; }
  .comparison-table th,.comparison-table td { padding:3px 5px; border:1px solid var(--border); text-align:left; }
  .comparison-table th { background:var(--surface); color:var(--accent); }
  .winner { color:var(--healthy); font-weight:600; }

  ::-webkit-scrollbar { width:5px; }
  ::-webkit-scrollbar-track { background:var(--surface); }
  ::-webkit-scrollbar-thumb { background:var(--border); border-radius:3px; }
</style>
</head>
<body>

<div class="app-header">
  <div>
    <h1><span>RCOA</span> Server Cluster Maintenance</h1>
    <div class="subtitle">Intelligent SRE Scheduling &mdash; Bio-Inspired Load Balancing &amp; Proactive Maintenance</div>
  </div>
</div>

<div class="main-layout">
  <!-- LEFT PANEL -->
  <div class="panel panel-left">
    <div class="panel-section">
      <h3>Cluster Configuration</h3>
      <div class="param-row">
        <label>Servers (Racks)</label>
        <input type="range" id="pServers" min="4" max="24" value="12">
        <span class="val" id="vServers">12</span>
      </div>
      <div class="param-row">
        <label>SRE Crews</label>
        <input type="range" id="pSRE" min="2" max="8" value="4">
        <span class="val" id="vSRE">4</span>
      </div>
      <div class="param-row">
        <label>Traffic Load</label>
        <input type="range" id="pTraffic" min="1" max="10" value="5">
        <span class="val" id="vTraffic">5</span>
      </div>
      <div class="param-row">
        <label>Degradation Rate</label>
        <input type="range" id="pDegRate" min="1" max="10" value="4">
        <span class="val" id="vDegRate">4</span>
      </div>
    </div>

    <div class="panel-section">
      <h3>RCOA Parameters</h3>
      <div class="param-row">
        <label>Cannibalism γ</label>
        <input type="range" id="pGamma" min="0" max="100" value="50">
        <span class="val" id="vGamma">0.50</span>
      </div>
      <div class="param-row">
        <label>Fertilization η</label>
        <input type="range" id="pEta" min="1" max="100" value="30">
        <span class="val" id="vEta">0.30</span>
      </div>
      <div class="param-row">
        <label>Bioturbation α</label>
        <input type="range" id="pAlpha" min="1" max="100" value="20">
        <span class="val" id="vAlpha">0.20</span>
      </div>
      <div class="param-row">
        <label>Stagnation τ</label>
        <input type="range" id="pTauStag" min="2" max="20" value="6">
        <span class="val" id="vTauStag">6</span>
      </div>
      <div class="param-row">
        <label>Molting Period</label>
        <input type="range" id="pTauMolt" min="5" max="30" value="12">
        <span class="val" id="vTauMolt">12</span>
      </div>
    </div>

    <div class="panel-section">
      <h3>Simulation</h3>
      <div class="param-row">
        <label>Speed</label>
        <input type="range" id="pSpeed" min="1" max="10" value="4">
        <span class="val" id="vSpeed">4</span>
      </div>
      <div class="param-row">
        <label><input type="checkbox" id="togInstant"> Instant Mode</label>
      </div>
      <div class="btn-row">
        <button class="btn primary" id="btnStart">Start</button>
        <button class="btn" id="btnPause">Pause</button>
        <button class="btn danger" id="btnReset">Reset</button>
      </div>
      <div class="btn-row" style="margin-top:7px;">
        <button class="btn" id="btnSpike">Traffic Spike!</button>
      </div>
      <div class="btn-row" style="margin-top:7px;">
        <button class="btn" id="btnCompare">Compare vs Round-Robin</button>
      </div>
    </div>

    <div class="panel-section">
      <h3>Operator Toggles</h3>
      <div class="param-row"><label><input type="checkbox" id="togFert" checked> Fertilization (Patching)</label></div>
      <div class="param-row"><label><input type="checkbox" id="togWeed" checked> Weeding (Load Shedding)</label></div>
      <div class="param-row"><label><input type="checkbox" id="togBio" checked> Bioturbation (Reboot)</label></div>
      <div class="param-row"><label><input type="checkbox" id="togMolt" checked> Molting (Scheduled Maint)</label></div>
    </div>
  </div>

  <!-- CENTER PANEL -->
  <div class="center-panel">
    <canvas id="simCanvas"></canvas>
    <div class="overlay-stats" id="overlayStats">
      <div class="sl"><span class="sk">Tick:</span><span class="sv" id="statTick">0</span></div>
      <div class="sl"><span class="sk">Avg Health:</span><span class="sv" id="statHealth">100%</span></div>
      <div class="sl"><span class="sk">Uptime:</span><span class="sv" id="statUptime">100%</span></div>
      <div class="sl"><span class="sk">Alerts:</span><span class="sv" id="statAlerts">0</span></div>
    </div>
    <div class="legend-bar">
      <div class="legend-item"><div class="legend-dot" style="background:var(--healthy)"></div> Healthy</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div> Degraded</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--critical)"></div> Critical</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--sre-orange)"></div> SRE (Working)</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--sre-blue)"></div> SRE (Patching)</div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="panel panel-right">
    <div class="panel-section">
      <h3>Cluster Metrics</h3>
      <div class="metric-grid">
        <div class="metric-card"><div class="mv" id="mAvgHealth" style="color:var(--healthy)">-</div><div class="ml">Avg Server Health</div></div>
        <div class="metric-card"><div class="mv" id="mCritical" style="color:var(--critical)">-</div><div class="ml">Critical Servers</div></div>
        <div class="metric-card"><div class="mv" id="mPatches" style="color:var(--sre-blue)">-</div><div class="ml">Patches Applied</div></div>
        <div class="metric-card"><div class="mv" id="mReboots" style="color:var(--warning)">-</div><div class="ml">Reboots</div></div>
      </div>
    </div>

    <div class="panel-section">
      <h3>Health Over Time</h3>
      <div class="chart-box"><canvas id="healthChart"></canvas></div>
    </div>

    <div class="panel-section">
      <h3>Operator Contributions</h3>
      <div style="font-size:0.7em; line-height:1.8;">
        <div class="param-row"><span style="color:var(--healthy);">●</span> Patches: <span id="contribPatch" style="color:var(--healthy);">0</span></div>
        <div class="param-row"><span style="color:var(--warning);">●</span> Load Shed: <span id="contribShed" style="color:var(--warning);">0</span></div>
        <div class="param-row"><span style="color:var(--sre-orange);">●</span> Reboots: <span id="contribReboot" style="color:var(--sre-orange);">0</span></div>
        <div class="param-row"><span style="color:var(--accent2);">●</span> Maint Windows: <span id="contribMaint" style="color:var(--accent2);">0</span></div>
      </div>
    </div>

    <div class="panel-section" id="compSection" style="display:none;">
      <h3>RCOA vs Round-Robin</h3>
      <table class="comparison-table" id="compTable">
        <tr><th>Metric</th><th>RCOA</th><th>Round-Robin</th></tr>
      </table>
    </div>

    <div class="panel-section">
      <h3>Why RCOA for Server Ops?</h3>
      <div style="font-size:0.68em; line-height:1.6; color:var(--text-dim);">
        <p><strong>Servers = Rice:</strong> Stationary resources that degrade over time (memory leaks, disk fragmentation, security vulnerabilities).</p>
        <p style="margin-top:6px;"><strong>SRE Crews = Crabs:</strong> Mobile agents that apply repairs. The density penalty (γ) prevents piling onto one server while others burn.</p>
        <p style="margin-top:6px;"><strong>Fertilization = Patching:</strong> Incremental health restoration with diminishing returns on crowded servers.</p>
        <p style="margin-top:6px;"><strong>Bioturbation = Reboot:</strong> When a server is stagnant (memory leak not clearing), a Lévy-distributed reboot jolt can restore health.</p>
        <p style="margin-top:6px;"><strong>Molting = Maintenance Windows:</strong> Lock healthy servers from modification to preserve SLA.</p>
      </div>
    </div>

    <div class="panel-section">
      <h3>Event Log</h3>
      <div class="event-log" id="eventLog"></div>
    </div>
  </div>
</div>

<script>
// ============================================================
// RCOA SERVER CLUSTER MAINTENANCE DEMO
// Demonstrates RCOA for intelligent SRE scheduling
// ============================================================

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const healthCanvas = document.getElementById('healthChart');
const healthCtx = healthCanvas.getContext('2d');

// State
let servers = [], sreCrews = [];
let iteration = 0, running = false, paused = false;
let healthHistory = [], rrHealthHistory = [];
let animFrame = null, lastTime = 0, accumulator = 0;
let opContrib = { patch: 0, shed: 0, reboot: 0, maint: 0 };
let alertCount = 0;

// Parameters
function P() {
  return {
    nServers: +document.getElementById('pServers').value,
    nSRE: +document.getElementById('pSRE').value,
    traffic: +document.getElementById('pTraffic').value,
    degRate: +document.getElementById('pDegRate').value,
    gamma: +document.getElementById('pGamma').value / 100,
    eta: +document.getElementById('pEta').value / 100,
    alpha: +document.getElementById('pAlpha').value / 100,
    tauStag: +document.getElementById('pTauStag').value,
    tauMolt: +document.getElementById('pTauMolt').value,
    speed: +document.getElementById('pSpeed').value,
    instantMode: document.getElementById('togInstant').checked,
    fertOn: document.getElementById('togFert').checked,
    weedOn: document.getElementById('togWeed').checked,
    bioOn: document.getElementById('togBio').checked,
    moltOn: document.getElementById('togMolt').checked,
  };
}

// Slider bindings
document.querySelectorAll('input[type=range]').forEach(el => {
  el.addEventListener('input', () => {
    const vid = 'v' + el.id.slice(1);
    const ve = document.getElementById(vid);
    if (!ve) return;
    let v = el.value;
    if (['pGamma','pEta','pAlpha'].includes(el.id)) v = (v/100).toFixed(2);
    ve.textContent = v;
  });
});

// Math utilities
function rand(a,b) { return a + Math.random()*(b-a); }
function clamp(v,lo,hi) { return Math.max(lo,Math.min(hi,v)); }
function gaussRand() {
  let u=0,v=0;
  while(!u) u=Math.random();
  while(!v) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function gamma_fn(z) {
  if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma_fn(1 - z));
  z -= 1;
  const g = 7;
  const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
    771.32342877765313, -176.61502916214059, 12.507343278686905,
    -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
  let x = c[0];
  for (let i = 1; i < g + 2; i++) x += c[i] / (z + i);
  const t = z + g + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
}
function levyStep(lam=1.5) {
  const sU = Math.pow(
    (gamma_fn(1+lam)*Math.sin(Math.PI*lam/2)) /
    (gamma_fn((1+lam)/2)*lam*Math.pow(2,(lam-1)/2)), 1/lam);
  const u = gaussRand()*sU, v = Math.abs(gaussRand());
  return u / Math.pow(v, 1/lam);
}
function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
function mean(arr) { return arr.reduce((a,b)=>a+b,0)/arr.length; }

// Resize
function resize() {
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * devicePixelRatio;
  canvas.height = rect.height * devicePixelRatio;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  
  const chartRect = healthCanvas.parentElement.getBoundingClientRect();
  healthCanvas.width = chartRect.width * devicePixelRatio;
  healthCanvas.height = chartRect.height * devicePixelRatio;
  healthCanvas.style.width = chartRect.width + 'px';
  healthCanvas.style.height = chartRect.height + 'px';
  healthCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
window.addEventListener('resize', resize);

// Initialize
function init() {
  resize();
  const p = P();
  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;

  servers = [];
  sreCrews = [];
  iteration = 0;
  healthHistory = [];
  rrHealthHistory = [];
  opContrib = { patch: 0, shed: 0, reboot: 0, maint: 0 };
  alertCount = 0;
  document.getElementById('compSection').style.display = 'none';

  // Create servers in rack layout
  const cols = Math.ceil(Math.sqrt(p.nServers * W / H));
  const rows = Math.ceil(p.nServers / cols);
  const cellW = (W - 100) / cols;
  const cellH = (H - 80) / rows;

  for (let i = 0; i < p.nServers; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    servers.push({
      id: i,
      x: 50 + col * cellW + cellW / 2,
      y: 40 + row * cellH + cellH / 2,
      health: rand(0.7, 1.0),
      load: rand(0.2, 0.6),
      stagnation: 0,
      lastHealth: 1.0,
      locked: false,
      lockTimer: 0,
      sreDensity: 0,
      memoryLeak: rand(0, 0.02),
      rackId: row,
    });
  }

  // Create SRE crews
  for (let j = 0; j < p.nSRE; j++) {
    const host = servers[j % p.nServers];
    sreCrews.push({
      id: j,
      x: host.x + gaussRand() * 20,
      y: host.y + gaussRand() * 20,
      vx: 0, vy: 0,
      target: null,
      state: 'Idle',
      patchesApplied: 0,
      recentImprovement: 0,
      moltTimer: 0,
    });
  }

  clearLog();
  log('sys', `Cluster initialized: ${p.nServers} servers, ${p.nSRE} SRE crews`);
  updateMetrics();
  draw();
}

// RCOA Step
function step() {
  const p = P();
  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;
  iteration++;

  // Phase 1: Degradation (load + memory leaks)
  servers.forEach(s => {
    if (!s.locked) {
      const loadDeg = (s.load * p.traffic / 10) * (p.degRate / 100);
      const leakDeg = s.memoryLeak;
      s.health = clamp(s.health - loadDeg - leakDeg, 0, 1);
      
      if (s.health < 0.2 && s.health > 0.15) {
        alertCount++;
        log('alert', `Server ${s.id} critical: ${(s.health*100).toFixed(0)}%`);
      }
    }
    s.sreDensity = 0;
    if (s.lockTimer > 0) {
      s.lockTimer--;
      if (s.lockTimer <= 0) s.locked = false;
    }
  });

  // Count SRE density
  sreCrews.forEach(sre => {
    if (sre.state === 'Patching' && sre.target !== null) {
      servers[sre.target].sreDensity++;
    }
  });

  // Phase 2: SRE movement and operators
  sreCrews.forEach(sre => {
    if (sre.state === 'Molting') {
      sre.moltTimer--;
      if (sre.moltTimer <= 0) {
        sre.state = 'Idle';
        log('sys', `SRE ${sre.id} back from break`);
      }
      return;
    }

    // Target selection: urgency with density penalty
    let bestAttr = -Infinity, bestIdx = -1;
    servers.forEach((s, i) => {
      const urgency = (1 - s.health) * 2 + s.load * 0.5;
      const attr = urgency / (1 + p.gamma * s.sreDensity);
      if (attr > bestAttr) { bestAttr = attr; bestIdx = i; }
    });

    sre.target = bestIdx;
    const target = servers[bestIdx];
    let d = dist(sre, target);

    // Instant mode
    if (p.instantMode) {
      sre.x = target.x + rand(-8, 8);
      sre.y = target.y + rand(-8, 8);
      d = 0;
    }

    // Movement
    const omega = 0.6;
    const u1 = Math.random(), u2 = Math.random();
    sre.vx = omega * sre.vx + 2.0 * u2 * (target.x - sre.x);
    sre.vy = omega * sre.vy + 2.0 * u2 * (target.y - sre.y);
    const spd = Math.hypot(sre.vx, sre.vy);
    if (spd > 12) { sre.vx *= 12/spd; sre.vy *= 12/spd; }
    sre.x = clamp(sre.x + sre.vx, 10, W-10);
    sre.y = clamp(sre.y + sre.vy, 10, H-10);

    // Operators when close
    if (d < 60) {
      sre.state = 'Patching';

      // Operator A: Weeding (load shedding)
      if (p.weedOn && !target.locked && target.load > 0.5) {
        const shed = 0.1;
        target.load = clamp(target.load - shed, 0.1, 1);
        opContrib.shed++;
        if (iteration % 30 === 0) log('patch', `Load shed on S${target.id}: load=${(target.load*100).toFixed(0)}%`);
      }

      // Operator B: Fertilization (patching)
      if (p.fertOn && !target.locked) {
        const densFactor = 1 / (1 + p.gamma * target.sreDensity);
        const patchGain = p.eta * densFactor * (1 - target.health) * 0.5;
        target.health = clamp(target.health + patchGain, 0, 1);
        sre.patchesApplied++;
        sre.recentImprovement += patchGain;
        opContrib.patch++;
        if (iteration % 25 === 0) log('patch', `Patched S${target.id}: health=${(target.health*100).toFixed(0)}%`);
      }

      // Operator C: Bioturbation (reboot on stagnation)
      if (p.bioOn && !target.locked) {
        if (Math.abs(target.health - target.lastHealth) < 0.005) {
          target.stagnation++;
        } else {
          target.stagnation = 0;
        }
        target.lastHealth = target.health;

        if (target.stagnation >= p.tauStag) {
          // Reboot: reset memory leak, big health boost
          target.memoryLeak = rand(0, 0.01);
          const rebootGain = Math.abs(levyStep(1.5)) * p.alpha * 0.3;
          target.health = clamp(target.health + rebootGain, 0, 1);
          target.stagnation = 0;
          opContrib.reboot++;
          log('reboot', `Rebooted S${target.id}: leak cleared, health=${(target.health*100).toFixed(0)}%`);
        }
      }

    } else {
      sre.state = 'Idle';
    }
  });

  // Phase 3: Molting (maintenance windows)
  if (p.moltOn && iteration % p.tauMolt === 0 && iteration > 0) {
    const sorted = [...sreCrews].filter(s => s.state !== 'Molting').sort((a,b) => a.recentImprovement - b.recentImprovement);
    const moltN = Math.max(1, Math.floor(sorted.length * 0.2));
    const topServers = [...servers].sort((a,b) => b.health - a.health).slice(0, moltN);

    for (let k = 0; k < moltN && k < sorted.length; k++) {
      const sre = sorted[k];
      const elite = topServers[k % topServers.length];
      sre.state = 'Molting';
      sre.moltTimer = 5;
      sre.recentImprovement = 0;
      elite.locked = true;
      elite.lockTimer = 5;
      opContrib.maint++;
      log('sys', `Maint window: SRE ${sre.id} break, S${elite.id} locked`);
    }
  }

  // Record history
  const avgHealth = mean(servers.map(s => s.health));
  healthHistory.push(avgHealth);
  if (healthHistory.length > 300) healthHistory.shift();

  updateMetrics();
}

// Round-Robin comparison
function runRRComparison() {
  const p = P();
  log('sys', 'Running Round-Robin comparison...');
  rrHealthHistory = [];

  // Clone servers
  const rrServers = servers.map(s => ({...s, health: rand(0.7, 1.0)}));
  let rrIdx = 0;

  for (let t = 0; t < Math.min(healthHistory.length, 200); t++) {
    // Degrade
    rrServers.forEach(s => {
      const loadDeg = (s.load * p.traffic / 10) * (p.degRate / 100);
      s.health = clamp(s.health - loadDeg - s.memoryLeak, 0, 1);
    });

    // Round-robin patching
    for (let j = 0; j < p.nSRE; j++) {
      const idx = (rrIdx + j) % rrServers.length;
      rrServers[idx].health = clamp(rrServers[idx].health + 0.1, 0, 1);
    }
    rrIdx = (rrIdx + 1) % rrServers.length;

    rrHealthHistory.push(mean(rrServers.map(s => s.health)));
  }

  // Show comparison
  const rcoaFinal = healthHistory.length > 0 ? healthHistory[healthHistory.length-1] : 0;
  const rrFinal = rrHealthHistory.length > 0 ? rrHealthHistory[rrHealthHistory.length-1] : 0;
  const rcoaMin = Math.min(...healthHistory.slice(-50));
  const rrMin = Math.min(...rrHealthHistory.slice(-50));

  document.getElementById('compSection').style.display = 'block';
  document.getElementById('compTable').innerHTML = `
    <tr><th>Metric</th><th>RCOA</th><th>Round-Robin</th></tr>
    <tr><td>Final Health</td><td class="${rcoaFinal > rrFinal ? 'winner' : ''}">${(rcoaFinal*100).toFixed(1)}%</td><td class="${rrFinal > rcoaFinal ? 'winner' : ''}">${(rrFinal*100).toFixed(1)}%</td></tr>
    <tr><td>Min Health</td><td class="${rcoaMin > rrMin ? 'winner' : ''}">${(rcoaMin*100).toFixed(1)}%</td><td class="${rrMin > rcoaMin ? 'winner' : ''}">${(rrMin*100).toFixed(1)}%</td></tr>
  `;
  log('sys', `Comparison done: RCOA ${(rcoaFinal*100).toFixed(1)}% vs RR ${(rrFinal*100).toFixed(1)}%`);
}

// Metrics
function updateMetrics() {
  const avgH = mean(servers.map(s => s.health));
  const critical = servers.filter(s => s.health < 0.3).length;
  
  document.getElementById('statTick').textContent = iteration;
  document.getElementById('statHealth').textContent = (avgH*100).toFixed(1) + '%';
  document.getElementById('statUptime').textContent = ((1 - critical/servers.length)*100).toFixed(1) + '%';
  document.getElementById('statAlerts').textContent = alertCount;

  document.getElementById('mAvgHealth').textContent = (avgH*100).toFixed(1) + '%';
  document.getElementById('mCritical').textContent = critical;
  document.getElementById('mPatches').textContent = opContrib.patch;
  document.getElementById('mReboots').textContent = opContrib.reboot;

  document.getElementById('contribPatch').textContent = opContrib.patch;
  document.getElementById('contribShed').textContent = opContrib.shed;
  document.getElementById('contribReboot').textContent = opContrib.reboot;
  document.getElementById('contribMaint').textContent = opContrib.maint;
}

// Logging
function log(type, msg) {
  const el = document.getElementById('eventLog');
  const cls = { patch:'ev-patch', reboot:'ev-reboot', alert:'ev-alert', traffic:'ev-traffic', sys:'ev-sys' }[type] || '';
  const prefix = { patch:'[PATCH]', reboot:'[REBOOT]', alert:'[ALERT]', traffic:'[TRAFFIC]', sys:'[SYS]' }[type] || '';
  el.innerHTML = `<div class="ev ${cls}">${prefix} t=${iteration}: ${msg}</div>` + el.innerHTML;
  if (el.children.length > 80) el.removeChild(el.lastChild);
}
function clearLog() { document.getElementById('eventLog').innerHTML = ''; }

// Drawing
function draw() {
  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;
  ctx.fillStyle = '#080c14';
  ctx.fillRect(0, 0, W, H);

  // Draw servers as rack units
  servers.forEach(s => {
    const w = 50, h = 35;
    
    // Server box
    let color = s.health > 0.7 ? '#4ade80' : s.health > 0.4 ? '#facc15' : '#f87171';
    ctx.fillStyle = s.locked ? 'rgba(192,132,252,0.2)' : 'rgba(30,41,59,0.8)';
    ctx.fillRect(s.x - w/2, s.y - h/2, w, h);
    ctx.strokeStyle = s.locked ? 'rgba(192,132,252,0.6)' : color;
    ctx.lineWidth = 2;
    ctx.strokeRect(s.x - w/2, s.y - h/2, w, h);

    // Health bar
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(s.x - w/2 + 3, s.y + h/2 - 8, w - 6, 5);
    ctx.fillStyle = color;
    ctx.fillRect(s.x - w/2 + 3, s.y + h/2 - 8, (w - 6) * s.health, 5);

    // Load indicator (LED lights)
    const leds = 4;
    for (let i = 0; i < leds; i++) {
      ctx.fillStyle = i < Math.ceil(s.load * leds) ? '#38bdf8' : '#1e293b';
      ctx.fillRect(s.x - w/2 + 5 + i*10, s.y - h/2 + 5, 6, 3);
    }

    // Label
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.font = '9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`S${s.id}`, s.x, s.y + 3);

    // Density indicator
    if (s.sreDensity > 0) {
      ctx.fillStyle = '#60a5fa';
      ctx.fillText(`ρ=${s.sreDensity}`, s.x, s.y + h/2 + 12);
    }
  });

  // Draw SRE crews
  sreCrews.forEach(sre => {
    let color = sre.state === 'Patching' ? '#60a5fa' : sre.state === 'Molting' ? '#c084fc' : '#fb923c';
    
    // Body
    ctx.beginPath();
    ctx.arc(sre.x, sre.y, 8, 0, Math.PI * 2);
    ctx.fillStyle = color + '99';
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Tool icon (wrench)
    ctx.save();
    ctx.translate(sre.x, sre.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-3, -3);
    ctx.lineTo(3, 3);
    ctx.moveTo(3, -3);
    ctx.lineTo(-3, 3);
    ctx.stroke();
    ctx.restore();

    // Connection to target
    if (sre.target !== null && sre.state !== 'Molting') {
      const t = servers[sre.target];
      ctx.beginPath();
      ctx.moveTo(sre.x, sre.y);
      ctx.lineTo(t.x, t.y);
      ctx.strokeStyle = sre.state === 'Patching' ? 'rgba(96,165,250,0.3)' : 'rgba(251,146,60,0.15)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  });

  // Draw health chart
  drawHealthChart();
}

function drawHealthChart() {
  const W = healthCanvas.width / devicePixelRatio;
  const H = healthCanvas.height / devicePixelRatio;
  healthCtx.fillStyle = '#1a2332';
  healthCtx.fillRect(0, 0, W, H);

  if (healthHistory.length < 2) return;

  // RCOA line
  healthCtx.beginPath();
  healthCtx.moveTo(0, H - healthHistory[0] * H);
  for (let i = 1; i < healthHistory.length; i++) {
    const x = (i / healthHistory.length) * W;
    const y = H - healthHistory[i] * H;
    healthCtx.lineTo(x, y);
  }
  healthCtx.strokeStyle = '#4ade80';
  healthCtx.lineWidth = 2;
  healthCtx.stroke();

  // RR line if available
  if (rrHealthHistory.length > 1) {
    healthCtx.beginPath();
    healthCtx.moveTo(0, H - rrHealthHistory[0] * H);
    for (let i = 1; i < rrHealthHistory.length; i++) {
      const x = (i / rrHealthHistory.length) * W;
      const y = H - rrHealthHistory[i] * H;
      healthCtx.lineTo(x, y);
    }
    healthCtx.strokeStyle = '#f87171';
    healthCtx.lineWidth = 2;
    healthCtx.stroke();
  }
}

// Animation
function animate(time) {
  if (!running || paused) return;
  const delta = time - lastTime;
  lastTime = time;
  accumulator += delta;

  const p = P();
  const stepMs = 1000 / (p.speed * 3);

  while (accumulator >= stepMs) {
    step();
    accumulator -= stepMs;
  }

  draw();
  animFrame = requestAnimationFrame(animate);
}

function start() {
  if (running && !paused) return;
  if (!running) init();
  running = true;
  paused = false;
  lastTime = performance.now();
  accumulator = 0;
  animFrame = requestAnimationFrame(animate);
}

function pause() {
  paused = !paused;
  if (!paused) {
    lastTime = performance.now();
    animFrame = requestAnimationFrame(animate);
  }
}

function reset() {
  running = false;
  paused = false;
  if (animFrame) cancelAnimationFrame(animFrame);
  init();
}

function trafficSpike() {
  servers.forEach(s => {
    s.load = clamp(s.load + rand(0.2, 0.4), 0, 1);
  });
  log('traffic', 'Traffic spike! Load increased across all servers');
}

// Event bindings
document.getElementById('btnStart').addEventListener('click', start);
document.getElementById('btnPause').addEventListener('click', pause);
document.getElementById('btnReset').addEventListener('click', reset);
document.getElementById('btnSpike').addEventListener('click', trafficSpike);
document.getElementById('btnCompare').addEventListener('click', runRRComparison);

// Initialize
init();
</script>
</body>
</html>
